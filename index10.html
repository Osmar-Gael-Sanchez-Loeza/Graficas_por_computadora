<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ordenamiento BubbleSort</title>
    <style>
        @import url("https://webglfundamentals.org/webgl/resources/webgl-tutorials.css");

        body {
            margin: 0;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
    <script>
        window.console = window.console || function (t) { };
    </script>
</head>
<body translate="no">
    <canvas id="canvas" width="797" height="277"></canvas>
    <!-- vertex shader -->
    <script id="vertex-shader-3d" type="x-shader/x-vertex">
        attribute vec4 a_position;
        attribute vec4 color;
        attribute mat4 matrix;
        uniform mat4 projection;
        uniform mat4 view;

        varying vec4 v_color;

        void main() {
        // Multiply the position by the matrix.
        gl_Position = projection * view * matrix * a_position;

        // Pass the vertex color to the fragment shader.
        v_color = color;
        }
    </script>
    <!-- fragment shader -->
    <script id="fragment-shader-3d" type="x-shader/x-fragment">
        precision mediump float;

        // Passed in from the vertex shader.
        varying vec4 v_color;

        void main() {
        gl_FragColor = v_color;
        }
    </script>
    <script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
    <script id="rendered-js">
        'use strict';

        function main() {
            // Get A WebGL context
            /** @type {HTMLCanvasElement} */
            const canvas = document.querySelector('#canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                return;
            }

            const ext = gl.getExtension('ANGLE_instanced_arrays');
            if (!ext) {
                return alert('need ANGLE_instanced_arrays'); // eslint-disable-line
            }

            // setup GLSL programs
            // compiles shaders, links program
            const program = webglUtils.createProgramFromScripts(
                gl, ['vertex-shader-3d', 'fragment-shader-3d']);

            const positionLoc = gl.getAttribLocation(program, 'a_position');
            const colorLoc = gl.getAttribLocation(program, 'color');
            const matrixLoc = gl.getAttribLocation(program, 'matrix');
            const projectionLoc = gl.getUniformLocation(program, 'projection');
            const viewLoc = gl.getUniformLocation(program, 'view');

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -0.1, 0.3,
                -0.1, -0.3,
                0.1, -0.3,
                0.1, -0.3,
                -0.1, 0.3,
                0.1, 0.3,
                0.3, -0.1,
                -0.3, -0.1,
                -0.3, 0.1,
                -0.3, 0.1,
                0.3, -0.1,
                0.3, 0.1]),
                gl.STATIC_DRAW);
            const numVertices = 12;

            // setup matrixes, one per instance
            const numInstances = 5;
            // make a typed array with one view per matrix
            const matrixData = new Float32Array(numInstances * 16);
            const matrices = [];
            for (let i = 0; i < numInstances; ++i) {
                const byteOffsetToMatrix = i * 16 * 4;
                const numFloatsForView = 16;
                matrices.push(new Float32Array(
                    matrixData.buffer,
                    byteOffsetToMatrix,
                    numFloatsForView));
            }

            const matrixBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
            // just allocate the buffer
            gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);

            // setup colors, one per instance
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array([
                    1, 0, 0, 1, // red
                    0, 1, 0, 1, // green
                    0, 0, 1, 1, // blue
                    1, 0, 1, 1, // magenta
                    0, 1, 1, 1 // cyan
                ]),
                gl.STATIC_DRAW);

            var tamaños = [];
            var posiciones = []
            // crear tamaños y posiciones iniciales
            for (let i = 6; i <= 10; i += 1) {
                tamaños.push(i/10);
                posiciones.push(i-6)
            }

            // Mezclar aleatoriamente los tamaños
            for (let i = tamaños.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                [tamaños[i], tamaños[j]] = [tamaños[j], tamaños[i]];
            }

            var _x = 0;// variables para la animación horizontal
            var _y = 0;// variables para la animación vertical
            var it = 0;// índice del primer elemento a comparar
            var ij = 0;// índice del segundo elemento a comparar
            var cont = 309;// contador de frames para la animación
            var estado = 0;// 0: sin animación, 1: animación de swap
            // Draw the scene.
            function render(time) {
                time *= 0.001; // seconds

                webglUtils.resizeCanvasToDisplaySize(gl.canvas);

                // Tell WebGL how to convert from clip space to pixels
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

                gl.useProgram(program);

                // set the view and projection matrices since
                // they are shared by all instances
                const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                gl.uniformMatrix4fv(projectionLoc, false,
                    m4.orthographic(-aspect, aspect, -1, 1, -1, 1));
                gl.uniformMatrix4fv(viewLoc, false, m4.zRotation(time * 0.0));
                // gl.uniformMatrix4fv(viewLoc, false, m4.zRotation(time * .1));

                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.enableVertexAttribArray(positionLoc);
                gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

                if(ij < tamaños.length){
                    cont++;// contador de frames para la animación
                    if(cont < 432){// animación de swap
                        if(estado){
                            if(cont < 44){// subir y bajar
                                _y = 0.6*cont/44;
                            }
                            else if(cont < 346){// mover horizontalmente
                                _x = (cont-43)/302;
                            }
                            else if(cont < 389){// bajar y subir
                                _y = 0.6*(44-(cont-345))/43;
                            }
                        }
                        else if(it != ij){// animación de comparación
                            if(cont < 352){// subir y bajar
                                _y = 0.3*(cont-308)/43;
                            }
                            else if(cont < 396){// bajar y subir
                                _y = 0.3*(44-(cont-351))/43;
                            }
                        }
                    }
                    else if(cont == 432){// fin de la iteracion de animación
                        if(estado){// hacer swap
                            [posiciones[it], posiciones[ij]] = [posiciones[ij], posiciones[it]];
                            [tamaños[it], tamaños[ij]] = [tamaños[ij], tamaños[it]];
                        }
                        ij++;
                        _x = 0;
                        _y = 0;
                        estado = 0;
                        if (ij == tamaños.length){// fin del array
                            it++;
                            ij = it + 1;
                        }
                        if(it < tamaños.length && tamaños[it] > tamaños[ij]){// hay que hacer swap
                            estado = 1;
                            cont = 0;
                        }
                        else{
                            cont = 309;// avanzar rápido hasta la siguiente comparación
                        }
                    }
                }

                // update all the matrices
                matrices.forEach((mat, ndx) => {
                    var indice = -1;// índice en el array posiciones
                    for(var i = 0; i < posiciones.length; i++){
                        if(posiciones[i] == ndx){// encontrar el índice correcto
                            indice = i;
                        }
                    }
                    if(indice == it){// mover a la derecha y/o arriba
                        m4.translation(-1 + indice * 0.6 + _x * (ij-it) * 0.6, _y, 0, mat);
                    }
                    else if(indice == ij){// mover a la izquierda y/o abajo
                        m4.translation(-1 + indice * 0.6 - _x * (ij-it) * 0.6, -_y, 0, mat);
                    }
                    else{// posición fija
                        m4.translation(-1 + indice * 0.6, 0, 0, mat);
                    }
                    var scale = m4.scaling(tamaños[indice], tamaños[indice], 1);
                    m4.multiply(mat, scale, mat); // aplicar escala sobre la transformación existente
                });

                // upload the new matrix data
                gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);

                // set all 4 attributes for matrix
                const bytesPerMatrix = 4 * 16;
                for (let i = 0; i < 4; ++i) {
                    const loc = matrixLoc + i;
                    gl.enableVertexAttribArray(loc);
                    // note the stride and offset
                    const offset = i * 16; // 4 floats per row, 4 bytes per float
                    gl.vertexAttribPointer(
                        loc, // location
                        4, // size (num values to pull from buffer per iteration)
                        gl.FLOAT, // type of data in buffer
                        false, // normalize
                        bytesPerMatrix, // stride, num bytes to advance to get to next set of values
                        offset // offset in buffer
                    );
                    // this line says this attribute only changes for each 1 instance
                    ext.vertexAttribDivisorANGLE(loc, 1);
                }

                // set attribute for color
                gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
                gl.enableVertexAttribArray(colorLoc);
                gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
                // this line says this attribute only changes for each 1 instance
                ext.vertexAttribDivisorANGLE(colorLoc, 1);

                ext.drawArraysInstancedANGLE(
                    gl.TRIANGLES,
                    0, // offset
                    numVertices, // num vertices per instance
                    numInstances // num instances
                );
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        main();
    </script>
</body>
</html>